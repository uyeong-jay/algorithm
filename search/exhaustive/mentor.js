//블루투포스(완전탐색): 멘토링

//이중 배열시 가로 세로 로 놓아 인덱스로 구분 해주기
const array = [
  [3, 4, 1, 2],
  [4, 3, 2, 1],
  [3, 1, 4, 2],
];

const solution = (arr) => {
  let answer = 0;

  m = arr.length; // 테스트수(세로)
  n = arr[0].length; // 학생수(가로1줄)

  // < 1. 멘토,멘티: 전체 경우의 수(4x4) 만들기 => 16가지 (이중 반복문) >
  // i: 멘토학생번호(4명)
  for (let i = 1; i <= n; i++) {
    //j: 멘티학생번호(4명)
    for (let j = 1; j <= n; j++) {

      //테스트 하기전 초기화 해놓기
      let cnt = 0; // 1번의 테스트에서 멘토 등수 < 멘티 등수 인 경우 수

      // < 2. 멘토,멘티: 만든 전체 16가지 중 하나씩 주어진 2차 배열에서 이중 반복문 돌리기 >
      // k: 테스트수(세로 인덱스)
      for (let k = 0; k < m; k++) {
        let pi; //멘토학생의 등수 변수 선언
        let pj; //멘티학생의 등수 변수 선언

        //s: 등수(가로 인덱스)
        //멘토, 멘티 등수 구하기
        for (let s = 0; s < n; s++) {
          if (arr[k][s] === i) pi = s;
          //따라서 배열의 요소(arr[k][s])가 멘토학생의 번호(i) 일때 그때의 등수(s)가 멘토학생의 등수(pi) 가 되도록함
          if (arr[k][s] === j) pj = s;
          //따라서 배열의 요소(arr[k][s])가 멘티학생의 번호(j) 일때 그때의 등수(s)가 멘티학생의 등수(pj) 가 되도록함
        }

        //테스트를 한번 하고 한쌍의 등수가 결정 된 후
        if (pi < pj) cnt++;
        // 등수는 작을 수록 높기 때문에 부등호는 반대로 해줌
        // 1번의 테스트에서 멘토 등수 < 멘티 등수 경우 >> cnt++
      }

      //테스트 3번 끝난 후
      if (cnt === m) answer++; // 테스트 3번 모두 멘티보다 멘토 등수가 높을 경우 >> 멘토,멘티 짝 성사 >> answer++;
    }
  }

  return answer;
};

console.log(solution(array));

//tip. 이중 반복문: 항상 1개당 나머지 반복
