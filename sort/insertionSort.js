//삽입정렬: 큰수는 두번째 반복문에서 계속해서 뒤로 복사해 나가고 작은 수는 첫번째 반복문 마지막에 한번만 배열의 가장 첫부분에 삽입 해주어 정렬해나가는 방법
//삽입: arr[j + 1] = tmp

//배열안 요소들을 정렬해보기
// - 정렬 메소드 배열.sort()를 써도 되지만
// - 왜 정렬이 되는지 그 안에서 이루어지는 정렬이 되는 과정을 배워보는 정렬 알고리즘 문제

const array = [11, 7, 5, 6, 10, 9];

const solution = (arr) => {
  let answer = arr; //let answer = [...arr];
  // 얕은 복사 - answer나 arr 둘중하나라도 바뀌면 둘다 바뀐다.

  for (let i = 0; i < arr.length; i++) {
    let tmp = arr[i]; //tmp: 임의 변수
    let j; //첫번째 반복문 과 두번째 반복문 에 모두 쓸수 있도록 두번째 반복문 바깥에 j를 선언해줌
    // 즉, 이렇게 변수로 따로 바깥에 분리를 해놓으면 두번째 반복문 안에서 계속 교체안해줘되고,
    // 두번째 반복문을 나온뒤 첫번째 반복문에서 교체해줄수있어서 교체횟수가 줄어듦

    //let j를 위에서 선언하여 밑에처럼 사용 가능
    for (j = i - 1; j >= 0; j--) {
      //j: --로 줄어들면서 i-1(큰 수) 부터 0(포함)(작은 수) 까지
      //(j 가 -1이 되면 j >= 0 이 거짓이 되어 이 반복문을 바로 벗어남)
      if (arr[j] > tmp) arr[j + 1] = arr[j];
      //arr[j]가 arr[i]보다 크면 j가 -1이 될때 까지 arr[j + 1](뒷숫자)를 arr[j](앞숫자)로 복사(바꾸기)
      else break; //조건에 맞지 않으면 이 반복문 벗어나기(break)
    }

    //위 두번째 반복문을 다 돌고 나면 j는 항상 -1이 되어 나옴
    arr[j + 1] = tmp; //(삽입, 대입)
    //따라서 j는 -1 이므로 arr[0]이 되고 arr[0](배열의 가장 첫부분)은 항상 arr[i](tmp)가 된다.
    //j를 위에서 첫번째 반복문안에 선언했기 때문에 여기서 사용 가능
    //두번째 반복문에서 나온뒤 첫번째 반복문 안에서 교체가능하여 교체횟수가 줄어듦
  }

  return answer;
};

console.log(solution(array));
